// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: tensorflow_serving/config/logging_config.proto
// Protobuf C++ Version: 5.29.0

#ifndef tensorflow_5fserving_2fconfig_2flogging_5fconfig_2eproto_2epb_2eh
#define tensorflow_5fserving_2fconfig_2flogging_5fconfig_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "tensorflow_serving/config/log_collector_config.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_tensorflow_5fserving_2fconfig_2flogging_5fconfig_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_tensorflow_5fserving_2fconfig_2flogging_5fconfig_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_tensorflow_5fserving_2fconfig_2flogging_5fconfig_2eproto;
namespace tensorflow {
namespace serving {
class LoggingConfig;
struct LoggingConfigDefaultTypeInternal;
extern LoggingConfigDefaultTypeInternal _LoggingConfig_default_instance_;
class SamplingConfig;
struct SamplingConfigDefaultTypeInternal;
extern SamplingConfigDefaultTypeInternal _SamplingConfig_default_instance_;
}  // namespace serving
}  // namespace tensorflow
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace tensorflow {
namespace serving {
enum SamplingConfig_Attributes : int {
  SamplingConfig_Attributes_ATTR_DEFAULT = 0,
  SamplingConfig_Attributes_ATTR_REQUEST_ORIGIN = 1,
  SamplingConfig_Attributes_ATTR_REQUEST_CRITICALITY = 2,
  SamplingConfig_Attributes_SamplingConfig_Attributes_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SamplingConfig_Attributes_SamplingConfig_Attributes_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SamplingConfig_Attributes_IsValid(int value);
extern const uint32_t SamplingConfig_Attributes_internal_data_[];
constexpr SamplingConfig_Attributes SamplingConfig_Attributes_Attributes_MIN = static_cast<SamplingConfig_Attributes>(0);
constexpr SamplingConfig_Attributes SamplingConfig_Attributes_Attributes_MAX = static_cast<SamplingConfig_Attributes>(2);
constexpr int SamplingConfig_Attributes_Attributes_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
SamplingConfig_Attributes_descriptor();
template <typename T>
const std::string& SamplingConfig_Attributes_Name(T value) {
  static_assert(std::is_same<T, SamplingConfig_Attributes>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Attributes_Name().");
  return SamplingConfig_Attributes_Name(static_cast<SamplingConfig_Attributes>(value));
}
template <>
inline const std::string& SamplingConfig_Attributes_Name(SamplingConfig_Attributes value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SamplingConfig_Attributes_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SamplingConfig_Attributes_Parse(absl::string_view name, SamplingConfig_Attributes* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SamplingConfig_Attributes>(
      SamplingConfig_Attributes_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class SamplingConfig final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.serving.SamplingConfig) */ {
 public:
  inline SamplingConfig() : SamplingConfig(nullptr) {}
  ~SamplingConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SamplingConfig* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SamplingConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SamplingConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline SamplingConfig(const SamplingConfig& from) : SamplingConfig(nullptr, from) {}
  inline SamplingConfig(SamplingConfig&& from) noexcept
      : SamplingConfig(nullptr, std::move(from)) {}
  inline SamplingConfig& operator=(const SamplingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SamplingConfig& operator=(SamplingConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SamplingConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const SamplingConfig* internal_default_instance() {
    return reinterpret_cast<const SamplingConfig*>(
        &_SamplingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(SamplingConfig& a, SamplingConfig& b) { a.Swap(&b); }
  inline void Swap(SamplingConfig* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SamplingConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SamplingConfig* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SamplingConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SamplingConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SamplingConfig& from) { SamplingConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SamplingConfig* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tensorflow.serving.SamplingConfig"; }

 protected:
  explicit SamplingConfig(::google::protobuf::Arena* arena);
  SamplingConfig(::google::protobuf::Arena* arena, const SamplingConfig& from);
  SamplingConfig(::google::protobuf::Arena* arena, SamplingConfig&& from) noexcept
      : SamplingConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Attributes = SamplingConfig_Attributes;
  static constexpr Attributes ATTR_DEFAULT = SamplingConfig_Attributes_ATTR_DEFAULT;
  static constexpr Attributes ATTR_REQUEST_ORIGIN = SamplingConfig_Attributes_ATTR_REQUEST_ORIGIN;
  static constexpr Attributes ATTR_REQUEST_CRITICALITY = SamplingConfig_Attributes_ATTR_REQUEST_CRITICALITY;
  static inline bool Attributes_IsValid(int value) {
    return SamplingConfig_Attributes_IsValid(value);
  }
  static constexpr Attributes Attributes_MIN = SamplingConfig_Attributes_Attributes_MIN;
  static constexpr Attributes Attributes_MAX = SamplingConfig_Attributes_Attributes_MAX;
  static constexpr int Attributes_ARRAYSIZE = SamplingConfig_Attributes_Attributes_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Attributes_descriptor() {
    return SamplingConfig_Attributes_descriptor();
  }
  template <typename T>
  static inline const std::string& Attributes_Name(T value) {
    return SamplingConfig_Attributes_Name(value);
  }
  static inline bool Attributes_Parse(absl::string_view name, Attributes* value) {
    return SamplingConfig_Attributes_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kSamplingRateFieldNumber = 1,
    kAttributesFieldNumber = 2,
  };
  // double sampling_rate = 1;
  void clear_sampling_rate() ;
  double sampling_rate() const;
  void set_sampling_rate(double value);

  private:
  double _internal_sampling_rate() const;
  void _internal_set_sampling_rate(double value);

  public:
  // int32 attributes = 2;
  void clear_attributes() ;
  ::int32_t attributes() const;
  void set_attributes(::int32_t value);

  private:
  ::int32_t _internal_attributes() const;
  void _internal_set_attributes(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.serving.SamplingConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SamplingConfig& from_msg);
    double sampling_rate_;
    ::int32_t attributes_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_5fserving_2fconfig_2flogging_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class LoggingConfig final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tensorflow.serving.LoggingConfig) */ {
 public:
  inline LoggingConfig() : LoggingConfig(nullptr) {}
  ~LoggingConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LoggingConfig* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LoggingConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoggingConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline LoggingConfig(const LoggingConfig& from) : LoggingConfig(nullptr, from) {}
  inline LoggingConfig(LoggingConfig&& from) noexcept
      : LoggingConfig(nullptr, std::move(from)) {}
  inline LoggingConfig& operator=(const LoggingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoggingConfig& operator=(LoggingConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoggingConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoggingConfig* internal_default_instance() {
    return reinterpret_cast<const LoggingConfig*>(
        &_LoggingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(LoggingConfig& a, LoggingConfig& b) { a.Swap(&b); }
  inline void Swap(LoggingConfig* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoggingConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoggingConfig* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LoggingConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LoggingConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LoggingConfig& from) { LoggingConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LoggingConfig* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tensorflow.serving.LoggingConfig"; }

 protected:
  explicit LoggingConfig(::google::protobuf::Arena* arena);
  LoggingConfig(::google::protobuf::Arena* arena, const LoggingConfig& from);
  LoggingConfig(::google::protobuf::Arena* arena, LoggingConfig&& from) noexcept
      : LoggingConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogCollectorConfigFieldNumber = 1,
    kSamplingConfigFieldNumber = 2,
  };
  // .tensorflow.serving.LogCollectorConfig log_collector_config = 1;
  bool has_log_collector_config() const;
  void clear_log_collector_config() ;
  const ::tensorflow::serving::LogCollectorConfig& log_collector_config() const;
  PROTOBUF_NODISCARD ::tensorflow::serving::LogCollectorConfig* release_log_collector_config();
  ::tensorflow::serving::LogCollectorConfig* mutable_log_collector_config();
  void set_allocated_log_collector_config(::tensorflow::serving::LogCollectorConfig* value);
  void unsafe_arena_set_allocated_log_collector_config(::tensorflow::serving::LogCollectorConfig* value);
  ::tensorflow::serving::LogCollectorConfig* unsafe_arena_release_log_collector_config();

  private:
  const ::tensorflow::serving::LogCollectorConfig& _internal_log_collector_config() const;
  ::tensorflow::serving::LogCollectorConfig* _internal_mutable_log_collector_config();

  public:
  // .tensorflow.serving.SamplingConfig sampling_config = 2;
  bool has_sampling_config() const;
  void clear_sampling_config() ;
  const ::tensorflow::serving::SamplingConfig& sampling_config() const;
  PROTOBUF_NODISCARD ::tensorflow::serving::SamplingConfig* release_sampling_config();
  ::tensorflow::serving::SamplingConfig* mutable_sampling_config();
  void set_allocated_sampling_config(::tensorflow::serving::SamplingConfig* value);
  void unsafe_arena_set_allocated_sampling_config(::tensorflow::serving::SamplingConfig* value);
  ::tensorflow::serving::SamplingConfig* unsafe_arena_release_sampling_config();

  private:
  const ::tensorflow::serving::SamplingConfig& _internal_sampling_config() const;
  ::tensorflow::serving::SamplingConfig* _internal_mutable_sampling_config();

  public:
  // @@protoc_insertion_point(class_scope:tensorflow.serving.LoggingConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LoggingConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::tensorflow::serving::LogCollectorConfig* log_collector_config_;
    ::tensorflow::serving::SamplingConfig* sampling_config_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_5fserving_2fconfig_2flogging_5fconfig_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SamplingConfig

// double sampling_rate = 1;
inline void SamplingConfig::clear_sampling_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sampling_rate_ = 0;
}
inline double SamplingConfig::sampling_rate() const {
  // @@protoc_insertion_point(field_get:tensorflow.serving.SamplingConfig.sampling_rate)
  return _internal_sampling_rate();
}
inline void SamplingConfig::set_sampling_rate(double value) {
  _internal_set_sampling_rate(value);
  // @@protoc_insertion_point(field_set:tensorflow.serving.SamplingConfig.sampling_rate)
}
inline double SamplingConfig::_internal_sampling_rate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sampling_rate_;
}
inline void SamplingConfig::_internal_set_sampling_rate(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sampling_rate_ = value;
}

// int32 attributes = 2;
inline void SamplingConfig::clear_attributes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attributes_ = 0;
}
inline ::int32_t SamplingConfig::attributes() const {
  // @@protoc_insertion_point(field_get:tensorflow.serving.SamplingConfig.attributes)
  return _internal_attributes();
}
inline void SamplingConfig::set_attributes(::int32_t value) {
  _internal_set_attributes(value);
  // @@protoc_insertion_point(field_set:tensorflow.serving.SamplingConfig.attributes)
}
inline ::int32_t SamplingConfig::_internal_attributes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.attributes_;
}
inline void SamplingConfig::_internal_set_attributes(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.attributes_ = value;
}

// -------------------------------------------------------------------

// LoggingConfig

// .tensorflow.serving.LogCollectorConfig log_collector_config = 1;
inline bool LoggingConfig::has_log_collector_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.log_collector_config_ != nullptr);
  return value;
}
inline const ::tensorflow::serving::LogCollectorConfig& LoggingConfig::_internal_log_collector_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::serving::LogCollectorConfig* p = _impl_.log_collector_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::serving::LogCollectorConfig&>(::tensorflow::serving::_LogCollectorConfig_default_instance_);
}
inline const ::tensorflow::serving::LogCollectorConfig& LoggingConfig::log_collector_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.serving.LoggingConfig.log_collector_config)
  return _internal_log_collector_config();
}
inline void LoggingConfig::unsafe_arena_set_allocated_log_collector_config(::tensorflow::serving::LogCollectorConfig* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.log_collector_config_);
  }
  _impl_.log_collector_config_ = reinterpret_cast<::tensorflow::serving::LogCollectorConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.serving.LoggingConfig.log_collector_config)
}
inline ::tensorflow::serving::LogCollectorConfig* LoggingConfig::release_log_collector_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::serving::LogCollectorConfig* released = _impl_.log_collector_config_;
  _impl_.log_collector_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::tensorflow::serving::LogCollectorConfig* LoggingConfig::unsafe_arena_release_log_collector_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.serving.LoggingConfig.log_collector_config)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tensorflow::serving::LogCollectorConfig* temp = _impl_.log_collector_config_;
  _impl_.log_collector_config_ = nullptr;
  return temp;
}
inline ::tensorflow::serving::LogCollectorConfig* LoggingConfig::_internal_mutable_log_collector_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.log_collector_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::serving::LogCollectorConfig>(GetArena());
    _impl_.log_collector_config_ = reinterpret_cast<::tensorflow::serving::LogCollectorConfig*>(p);
  }
  return _impl_.log_collector_config_;
}
inline ::tensorflow::serving::LogCollectorConfig* LoggingConfig::mutable_log_collector_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tensorflow::serving::LogCollectorConfig* _msg = _internal_mutable_log_collector_config();
  // @@protoc_insertion_point(field_mutable:tensorflow.serving.LoggingConfig.log_collector_config)
  return _msg;
}
inline void LoggingConfig::set_allocated_log_collector_config(::tensorflow::serving::LogCollectorConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.log_collector_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.log_collector_config_ = reinterpret_cast<::tensorflow::serving::LogCollectorConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.serving.LoggingConfig.log_collector_config)
}

// .tensorflow.serving.SamplingConfig sampling_config = 2;
inline bool LoggingConfig::has_sampling_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sampling_config_ != nullptr);
  return value;
}
inline void LoggingConfig::clear_sampling_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sampling_config_ != nullptr) _impl_.sampling_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::tensorflow::serving::SamplingConfig& LoggingConfig::_internal_sampling_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tensorflow::serving::SamplingConfig* p = _impl_.sampling_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::tensorflow::serving::SamplingConfig&>(::tensorflow::serving::_SamplingConfig_default_instance_);
}
inline const ::tensorflow::serving::SamplingConfig& LoggingConfig::sampling_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tensorflow.serving.LoggingConfig.sampling_config)
  return _internal_sampling_config();
}
inline void LoggingConfig::unsafe_arena_set_allocated_sampling_config(::tensorflow::serving::SamplingConfig* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sampling_config_);
  }
  _impl_.sampling_config_ = reinterpret_cast<::tensorflow::serving::SamplingConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.serving.LoggingConfig.sampling_config)
}
inline ::tensorflow::serving::SamplingConfig* LoggingConfig::release_sampling_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tensorflow::serving::SamplingConfig* released = _impl_.sampling_config_;
  _impl_.sampling_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::tensorflow::serving::SamplingConfig* LoggingConfig::unsafe_arena_release_sampling_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tensorflow.serving.LoggingConfig.sampling_config)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::tensorflow::serving::SamplingConfig* temp = _impl_.sampling_config_;
  _impl_.sampling_config_ = nullptr;
  return temp;
}
inline ::tensorflow::serving::SamplingConfig* LoggingConfig::_internal_mutable_sampling_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sampling_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tensorflow::serving::SamplingConfig>(GetArena());
    _impl_.sampling_config_ = reinterpret_cast<::tensorflow::serving::SamplingConfig*>(p);
  }
  return _impl_.sampling_config_;
}
inline ::tensorflow::serving::SamplingConfig* LoggingConfig::mutable_sampling_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::tensorflow::serving::SamplingConfig* _msg = _internal_mutable_sampling_config();
  // @@protoc_insertion_point(field_mutable:tensorflow.serving.LoggingConfig.sampling_config)
  return _msg;
}
inline void LoggingConfig::set_allocated_sampling_config(::tensorflow::serving::SamplingConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.sampling_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.sampling_config_ = reinterpret_cast<::tensorflow::serving::SamplingConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.serving.LoggingConfig.sampling_config)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace serving
}  // namespace tensorflow


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::tensorflow::serving::SamplingConfig_Attributes> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::tensorflow::serving::SamplingConfig_Attributes>() {
  return ::tensorflow::serving::SamplingConfig_Attributes_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // tensorflow_5fserving_2fconfig_2flogging_5fconfig_2eproto_2epb_2eh
